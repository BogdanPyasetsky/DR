using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;



namespace DR
{
    class Program
    {
        //AES 

        static byte[] S_Block = { 0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
  0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
  0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
  0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
  0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
  0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
  0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
  0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
  0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
  0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
  0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
  0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
  0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
  0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
  0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
  0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16};

        //Kalina 1
        /*
        static byte[] S_Block = { 0xA8, 0x43, 0x5F, 0x06, 0x6B, 0x75, 0x6C, 0x59, 0x71, 0xDF, 0x87, 0x95, 0x17, 0xF0, 0xD8, 0x09,
 0x6D, 0xF3, 0x1D, 0xCB, 0xC9, 0x4D, 0x2C, 0xAF, 0x79, 0xE0, 0x97, 0xFD, 0x6F, 0x4B, 0x45, 0x39,
 0x3E, 0xDD, 0xA3, 0x4F, 0xB4, 0xB6, 0x9A, 0x0E, 0x1F, 0xBF, 0x15, 0xE1, 0x49, 0xD2, 0x93, 0xC6,
 0x92, 0x72, 0x9E, 0x61, 0xD1, 0x63, 0xFA, 0xEE, 0xF4, 0x19, 0xD5, 0xAD, 0x58, 0xA4, 0xBB, 0xA1,
 0xDC, 0xF2, 0x83, 0x37, 0x42, 0xE4, 0x7A, 0x32, 0x9C, 0xCC, 0xAB, 0x4A, 0x8F, 0x6E, 0x04, 0x27,
 0x2E, 0xE7, 0xE2, 0x5A, 0x96, 0x16, 0x23, 0x2B, 0xC2, 0x65, 0x66, 0x0F, 0xBC, 0xA9, 0x47, 0x41,
 0x34, 0x48, 0xFC, 0xB7, 0x6A, 0x88, 0xA5, 0x53, 0x86, 0xF9, 0x5B, 0xDB, 0x38, 0x7B, 0xC3, 0x1E,
 0x22, 0x33, 0x24, 0x28, 0x36, 0xC7, 0xB2, 0x3B, 0x8E, 0x77, 0xBA, 0xF5, 0x14, 0x9F, 0x08, 0x55,
 0x9B, 0x4C, 0xFE, 0x60, 0x5C, 0xDA, 0x18, 0x46, 0xCD, 0x7D, 0x21, 0xB0, 0x3F, 0x1B, 0x89, 0xFF,
 0xEB, 0x84, 0x69, 0x3A, 0x9D, 0xD7, 0xD3, 0x70, 0x67, 0x40, 0xB5, 0xDE, 0x5D, 0x30, 0x91, 0xB1,
 0x78, 0x11, 0x01, 0xE5, 0x00, 0x68, 0x98, 0xA0, 0xC5, 0x02, 0xA6, 0x74, 0x2D, 0x0B, 0xA2, 0x76,
 0xB3, 0xBE, 0xCE, 0xBD, 0xAE, 0xE9, 0x8A, 0x31, 0x1C, 0xEC, 0xF1, 0x99, 0x94, 0xAA, 0xF6, 0x26,
 0x2F, 0xEF, 0xE8, 0x8C, 0x35, 0x03, 0xD4, 0x7F, 0xFB, 0x05, 0xC1, 0x5E, 0x90, 0x20, 0x3D, 0x82,
 0xF7, 0xEA, 0x0A, 0x0D, 0x7E, 0xF8, 0x50, 0x1A, 0xC4, 0x07, 0x57, 0xB8, 0x3C, 0x62, 0xE3, 0xC8,
 0xAC, 0x52, 0x64, 0x10, 0xD0, 0xD9, 0x13, 0x0C, 0x12, 0x29, 0x51, 0xB9, 0xCF, 0xD6, 0x73, 0x8D,
 0x81, 0x54, 0xC0, 0xED, 0x4E, 0x44, 0xA7, 0x2A, 0x85, 0x25, 0xE6, 0xCA, 0x7C, 0x8B, 0x56, 0x80};*/

        //Kalina 2
        /*
        static byte[] S_Block = { 0xCE, 0xBB, 0xEB, 0x92, 0xEA, 0xCB, 0x13, 0xC1, 0xE9, 0x3A, 0xD6, 0xB2, 0xD2, 0x90, 0x17, 0xF8,
 0x42, 0x15, 0x56, 0xB4, 0x65, 0x1C, 0x88, 0x43, 0xC5, 0x5C, 0x36, 0xBA, 0xF5, 0x57, 0x67, 0x8D,
 0x31, 0xF6, 0x64, 0x58, 0x9E, 0xF4, 0x22, 0xAA, 0x75, 0x0F, 0x02, 0xB1, 0xDF, 0x6D, 0x73, 0x4D,
 0x7C, 0x26, 0x2E, 0xF7, 0x08, 0x5D, 0x44, 0x3E, 0x9F, 0x14, 0xC8, 0xAE, 0x54, 0x10, 0xD8, 0xBC,
 0x1A, 0x6B, 0x69, 0xF3, 0xBD, 0x33, 0xAB, 0xFA, 0xD1, 0x9B, 0x68, 0x4E, 0x16, 0x95, 0x91, 0xEE,
 0x4C, 0x63, 0x8E, 0x5B, 0xCC, 0x3C, 0x19, 0xA1, 0x81, 0x49, 0x7B, 0xD9, 0x6F, 0x37, 0x60, 0xCA,
 0xE7, 0x2B, 0x48, 0xFD, 0x96, 0x45, 0xFC, 0x41, 0x12, 0x0D, 0x79, 0xE5, 0x89, 0x8C, 0xE3, 0x20,
 0x30, 0xDC, 0xB7, 0x6C, 0x4A, 0xB5, 0x3F, 0x97, 0xD4, 0x62, 0x2D, 0x06, 0xA4, 0xA5, 0x83, 0x5F,
 0x2A, 0xDA, 0xC9, 0x00, 0x7E, 0xA2, 0x55, 0xBF, 0x11, 0xD5, 0x9C, 0xCF, 0x0E, 0x0A, 0x3D, 0x51,
 0x7D, 0x93, 0x1B, 0xFE, 0xC4, 0x47, 0x09, 0x86, 0x0B, 0x8F, 0x9D, 0x6A, 0x07, 0xB9, 0xB0, 0x98,
 0x18, 0x32, 0x71, 0x4B, 0xEF, 0x3B, 0x70, 0xA0, 0xE4, 0x40, 0xFF, 0xC3, 0xA9, 0xE6, 0x78, 0xF9,
 0x8B, 0x46, 0x80, 0x1E, 0x38, 0xE1, 0xB8, 0xA8, 0xE0, 0x0C, 0x23, 0x76, 0x1D, 0x25, 0x24, 0x05,
 0xF1, 0x6E, 0x94, 0x28, 0x9A, 0x84, 0xE8, 0xA3, 0x4F, 0x77, 0xD3, 0x85, 0xE2, 0x52, 0xF2, 0x82,
 0x50, 0x7A, 0x2F, 0x74, 0x53, 0xB3, 0x61, 0xAF, 0x39, 0x35, 0xDE, 0xCD, 0x1F, 0x99, 0xAC, 0xAD,
 0x72, 0x2C, 0xDD, 0xD0, 0x87, 0xBE, 0x5E, 0xA6, 0xEC, 0x04, 0xC6, 0x03, 0x34, 0xFB, 0xDB, 0x59,
 0xB6, 0xC2, 0x01, 0xF0, 0x5A, 0xED, 0xA7, 0x66, 0x21, 0x7F, 0x8A, 0x27, 0xC7, 0xC0, 0x29, 0xD7};*/

        //Kalina 3
        /*
        static byte[] S_Block = { 0x93, 0xD9, 0x9A, 0xB5, 0x98, 0x22, 0x45, 0xFC, 0xBA, 0x6A, 0xDF, 0x02, 0x9F, 0xDC, 0x51, 0x59,
 0x4A, 0x17, 0x2B, 0xC2, 0x94, 0xF4, 0xBB, 0xA3, 0x62, 0xE4, 0x71, 0xD4, 0xCD, 0x70, 0x16, 0xE1,
 0x49, 0x3C, 0xC0, 0xD8, 0x5C, 0x9B, 0xAD, 0x85, 0x53, 0xA1, 0x7A, 0xC8, 0x2D, 0xE0, 0xD1, 0x72,
 0xA6, 0x2C, 0xC4, 0xE3, 0x76, 0x78, 0xB7, 0xB4, 0x09, 0x3B, 0x0E, 0x41, 0x4C, 0xDE, 0xB2, 0x90,
 0x25, 0xA5, 0xD7, 0x03, 0x11, 0x00, 0xC3, 0x2E, 0x92, 0xEF, 0x4E, 0x12, 0x9D, 0x7D, 0xCB, 0x35,
 0x10, 0xD5, 0x4F, 0x9E, 0x4D, 0xA9, 0x55, 0xC6, 0xD0, 0x7B, 0x18, 0x97, 0xD3, 0x36, 0xE6, 0x48,
 0x56, 0x81, 0x8F, 0x77, 0xCC, 0x9C, 0xB9, 0xE2, 0xAC, 0xB8, 0x2F, 0x15, 0xA4, 0x7C, 0xDA, 0x38,
 0x1E, 0x0B, 0x05, 0xD6, 0x14, 0x6E, 0x6C, 0x7E, 0x66, 0xFD, 0xB1, 0xE5, 0x60, 0xAF, 0x5E, 0x33,
 0x87, 0xC9, 0xF0, 0x5D, 0x6D, 0x3F, 0x88, 0x8D, 0xC7, 0xF7, 0x1D, 0xE9, 0xEC, 0xED, 0x80, 0x29,
 0x27, 0xCF, 0x99, 0xA8, 0x50, 0x0F, 0x37, 0x24, 0x28, 0x30, 0x95, 0xD2, 0x3E, 0x5B, 0x40, 0x83,
 0xB3, 0x69, 0x57, 0x1F, 0x07, 0x1C, 0x8A, 0xBC, 0x20, 0xEB, 0xCE, 0x8E, 0xAB, 0xEE, 0x31, 0xA2,
 0x73, 0xF9, 0xCA, 0x3A, 0x1A, 0xFB, 0x0D, 0xC1, 0xFE, 0xFA, 0xF2, 0x6F, 0xBD, 0x96, 0xDD, 0x43,
 0x52, 0xB6, 0x08, 0xF3, 0xAE, 0xBE, 0x19, 0x89, 0x32, 0x26, 0xB0, 0xEA, 0x4B, 0x64, 0x84, 0x82,
 0x6B, 0xF5, 0x79, 0xBF, 0x01, 0x5F, 0x75, 0x63, 0x1B, 0x23, 0x3D, 0x68, 0x2A, 0x65, 0xE8, 0x91,
 0xF6, 0xFF, 0x13, 0x58, 0xF1, 0x47, 0x0A, 0x7F, 0xC5, 0xA7, 0xE7, 0x61, 0x5A, 0x06, 0x46, 0x44,
 0x42, 0x04, 0xA0, 0xDB, 0x39, 0x86, 0x54, 0xAA, 0x8C, 0x34, 0x21, 0x8B, 0xF8, 0x0C, 0x74, 0x67};*/

        //Kalina 4
        /*
        static byte[] S_Block = { 0x68, 0x8D, 0xCA, 0x4D, 0x73, 0x4B, 0x4E, 0x2A, 0xD4, 0x52, 0x26, 0xB3, 0x54, 0x1E, 0x19, 0x1F,
 0x22, 0x03, 0x46, 0x3D, 0x2D, 0x4A, 0x53, 0x83, 0x13, 0x8A, 0xB7, 0xD5, 0x25, 0x79, 0xF5, 0xBD,
 0x58, 0x2F, 0x0D, 0x02, 0xED, 0x51, 0x9E, 0x11, 0xF2, 0x3E, 0x55, 0x5E, 0xD1, 0x16, 0x3C, 0x66,
 0x70, 0x5D, 0xF3, 0x45, 0x40, 0xCC, 0xE8, 0x94, 0x56, 0x08, 0xCE, 0x1A, 0x3A, 0xD2, 0xE1, 0xDF,
 0xB5, 0x38, 0x6E, 0x0E, 0xE5, 0xF4, 0xF9, 0x86, 0xE9, 0x4F, 0xD6, 0x85, 0x23, 0xCF, 0x32, 0x99,
 0x31, 0x14, 0xAE, 0xEE, 0xC8, 0x48, 0xD3, 0x30, 0xA1, 0x92, 0x41, 0xB1, 0x18, 0xC4, 0x2C, 0x71,
 0x72, 0x44, 0x15, 0xFD, 0x37, 0xBE, 0x5F, 0xAA, 0x9B, 0x88, 0xD8, 0xAB, 0x89, 0x9C, 0xFA, 0x60,
 0xEA, 0xBC, 0x62, 0x0C, 0x24, 0xA6, 0xA8, 0xEC, 0x67, 0x20, 0xDB, 0x7C, 0x28, 0xDD, 0xAC, 0x5B,
 0x34, 0x7E, 0x10, 0xF1, 0x7B, 0x8F, 0x63, 0xA0, 0x05, 0x9A, 0x43, 0x77, 0x21, 0xBF, 0x27, 0x09,
 0xC3, 0x9F, 0xB6, 0xD7, 0x29, 0xC2, 0xEB, 0xC0, 0xA4, 0x8B, 0x8C, 0x1D, 0xFB, 0xFF, 0xC1, 0xB2,
 0x97, 0x2E, 0xF8, 0x65, 0xF6, 0x75, 0x07, 0x04, 0x49, 0x33, 0xE4, 0xD9, 0xB9, 0xD0, 0x42, 0xC7,
 0x6C, 0x90, 0x00, 0x8E, 0x6F, 0x50, 0x01, 0xC5, 0xDA, 0x47, 0x3F, 0xCD, 0x69, 0xA2, 0xE2, 0x7A,
 0xA7, 0xC6, 0x93, 0x0F, 0x0A, 0x06, 0xE6, 0x2B, 0x96, 0xA3, 0x1C, 0xAF, 0x6A, 0x12, 0x84, 0x39,
 0xE7, 0xB0, 0x82, 0xF7, 0xFE, 0x9D, 0x87, 0x5C, 0x81, 0x35, 0xDE, 0xB4, 0xA5, 0xFC, 0x80, 0xEF,
 0xCB, 0xBB, 0x6B, 0x76, 0xBA, 0x5A, 0x7D, 0x78, 0x0B, 0x95, 0xE3, 0xAD, 0x74, 0x98, 0x3B, 0x36,
 0x64, 0x6D, 0xDC, 0xF0, 0x59, 0xA9, 0x4C, 0x17, 0x7F, 0x91, 0xB8, 0xC9, 0x57, 0x1B, 0xE0, 0x61};*/

        //Kuznechik
        /*
        static byte[] S_Block = { 252, 238, 221, 17, 207, 110, 49, 22, 251, 196, 250, 218, 35, 197, 4, 77, 
233, 119, 240, 219, 147, 46, 153, 186, 23, 54, 241, 187, 20, 205, 95, 193, 
249, 24, 101, 90, 226, 92, 239, 33, 129, 28, 60, 66, 139, 1, 142, 79, 5, 
132, 2, 174, 227, 106, 143, 160, 6, 11, 237, 152, 127, 212, 211, 31, 235, 52, 44, 81, 
234, 200, 72, 171, 242, 42, 104, 162, 253, 58, 206, 204, 181, 112, 14, 86, 8, 12, 
118, 18, 191, 114, 19, 71, 156, 183, 93, 135, 21, 161, 150, 41, 16, 123, 154, 199, 
243, 145, 120, 111, 157, 158, 178, 177, 50, 117, 25, 61, 255, 53, 138, 126, 109, 84, 
198, 128, 195, 189, 13, 87, 223, 245, 36, 169, 62, 168, 67, 201, 215, 121, 214, 246, 
124, 34, 185, 3, 224, 15, 236, 222, 122, 148, 176, 188, 220, 232, 40, 80, 78, 51, 10, 74, 
167, 151, 96, 115, 30, 0, 98, 68, 26, 184, 56, 130, 100, 159, 38, 65, 173, 69, 70, 
146, 39, 94, 85, 47, 140, 163, 165, 125, 105, 213, 149, 59, 7, 88, 179, 64, 134, 
172, 29, 247, 48, 55, 107, 228, 136, 217, 231, 137, 225, 27, 131, 73, 76, 63, 248, 
254, 141, 83, 170, 144, 202, 216, 133, 97, 32, 113, 103, 164, 45, 43, 9, 91, 203, 155, 37, 
208, 190, 229, 108, 82, 89, 166, 116, 210, 230, 244, 180, 192, 209, 102, 175, 194, 57, 75, 99, 182};*/

        //STB
        /*
        static byte[] S_Block = { 0xB1, 0x94, 0xBA, 0xC8, 0x0A, 0x08, 0xF5, 0x3B, 0x36, 0x6D, 0x00, 0x8E, 0x58, 0x4A, 0x5D, 0xE4,
0x85, 0x04, 0xFA, 0x9D, 0x1B, 0xB6, 0xC7, 0xAC, 0x25, 0x2E, 0x72, 0xC2, 0x02, 0xFD, 0xCE, 0x0D,
0x5B, 0xE3, 0xD6, 0x12, 0x17, 0xB9, 0x61, 0x81, 0xFE, 0x67, 0x86, 0xAD, 0x71, 0x6B, 0x89, 0x0B,
0x5C, 0xB0, 0xC0, 0xFF, 0x33, 0xC3, 0x56, 0xB8, 0x35, 0xC4, 0x05, 0xAE, 0xD8, 0xE0, 0x7F, 0x99,
0xE1, 0x2B, 0xDC, 0x1A, 0xE2, 0x82, 0x57, 0xEC, 0x70, 0x3F, 0xCC, 0xF0, 0x95, 0xEE, 0x8D, 0xF1,
0xC1, 0xAB, 0x76, 0x38, 0x9F, 0xE6, 0x78, 0xCA, 0xF7, 0xC6, 0xF8, 0x60, 0xD5, 0xBB, 0x9C, 0x4F,
0xF3, 0x3C, 0x65, 0x7B, 0x63, 0x7C, 0x30, 0x6A, 0xDD, 0x4E, 0xA7, 0x79, 0x9E, 0xB2, 0x3D, 0x31,
0x3E, 0x98, 0xB5, 0x6E, 0x27, 0xD3, 0xBC, 0xCF, 0x59, 0x1E, 0x18, 0x1F, 0x4C, 0x5A, 0xB7, 0x93,
0xE9, 0xDE, 0xE7, 0x2C, 0x8F, 0x0C, 0x0F, 0xA6, 0x2D, 0xDB, 0x49, 0xF4, 0x6F, 0x73, 0x96, 0x47,
0x06, 0x07, 0x53, 0x16, 0xED, 0x24, 0x7A, 0x37, 0x39, 0xCB, 0xA3, 0x83, 0x03, 0xA9, 0x8B, 0xF6,
0x92, 0xBD, 0x9B, 0x1C, 0xE5, 0xD1, 0x41, 0x01, 0x54, 0x45, 0xFB, 0xC9, 0x5E, 0x4D, 0x0E, 0xF2,
0x68, 0x20, 0x80, 0xAA, 0x22, 0x7D, 0x64, 0x2F, 0x26, 0x87, 0xF9, 0x34, 0x90, 0x40, 0x55, 0x11,
0xBE, 0x32, 0x97, 0x13, 0x43, 0xFC, 0x9A, 0x48, 0xA0, 0x2A, 0x88, 0x5F, 0x19, 0x4B, 0x09, 0xA1,
0x7E, 0xCD, 0xA4, 0xD0, 0x15, 0x44, 0xAF, 0x8C, 0xA5, 0x84, 0x50, 0xBF, 0x66, 0xD2, 0xE8, 0x8A,
0xA2, 0xD7, 0x46, 0x52, 0x42, 0xA8, 0xDF, 0xB3, 0x69, 0x74, 0xC5, 0x51, 0xEB, 0x23, 0x29, 0x21,
0xD4, 0xEF, 0xD9, 0xB4, 0x3A, 0x62, 0x28, 0x75, 0x91, 0x14, 0x10, 0xEA, 0x77, 0x6C, 0xDA, 0x1D};*/


        //Aria 2
        /*
        static byte[] S_Block = { 0xe2, 0x4e, 0x54, 0xfc, 0x94, 0xc2, 0x4a, 0xcc, 0x62, 0x0d, 0x6a, 0x46, 0x3c, 0x4d, 0x8b, 0xd1, 
 0x5e, 0xfa, 0x64, 0xcb, 0xb4, 0x97, 0xbe, 0x2b, 0xbc, 0x77, 0x2e, 0x03, 0xd3, 0x19, 0x59, 0xc1, 
 0x1d, 0x06, 0x41, 0x6b, 0x55, 0xf0, 0x99, 0x69, 0xea, 0x9c, 0x18, 0xae, 0x63, 0xdf, 0xe7, 0xbb, 
 0x00, 0x73, 0x66, 0xfb, 0x96, 0x4c, 0x85, 0xe4, 0x3a, 0x09, 0x45, 0xaa, 0x0f, 0xee, 0x10, 0xeb, 
 0x2d, 0x7f, 0xf4, 0x29, 0xac, 0xcf, 0xad, 0x91, 0x8d, 0x78, 0xc8, 0x95, 0xf9, 0x2f, 0xce, 0xcd, 
 0x08, 0x7a, 0x88, 0x38, 0x5c, 0x83, 0x2a, 0x28, 0x47, 0xdb, 0xb8, 0xc7, 0x93, 0xa4, 0x12, 0x53, 
 0xff, 0x87, 0x0e, 0x31, 0x36, 0x21, 0x58, 0x48, 0x01, 0x8e, 0x37, 0x74, 0x32, 0xca, 0xe9, 0xb1, 
 0xb7, 0xab, 0x0c, 0xd7, 0xc4, 0x56, 0x42, 0x26, 0x07, 0x98, 0x60, 0xd9, 0xb6, 0xb9, 0x11, 0x40, 
 0xec, 0x20, 0x8c, 0xbd, 0xa0, 0xc9, 0x84, 0x04, 0x49, 0x23, 0xf1, 0x4f, 0x50, 0x1f, 0x13, 0xdc, 
 0xd8, 0xc0, 0x9e, 0x57, 0xe3, 0xc3, 0x7b, 0x65, 0x3b, 0x02, 0x8f, 0x3e, 0xe8, 0x25, 0x92, 0xe5, 
 0x15, 0xdd, 0xfd, 0x17, 0xa9, 0xbf, 0xd4, 0x9a, 0x7e, 0xc5, 0x39, 0x67, 0xfe, 0x76, 0x9d, 0x43, 
 0xa7, 0xe1, 0xd0, 0xf5, 0x68, 0xf2, 0x1b, 0x34, 0x70, 0x05, 0xa3, 0x8a, 0xd5, 0x79, 0x86, 0xa8, 
 0x30, 0xc6, 0x51, 0x4b, 0x1e, 0xa6, 0x27, 0xf6, 0x35, 0xd2, 0x6e, 0x24, 0x16, 0x82, 0x5f, 0xda, 
 0xe6, 0x75, 0xa2, 0xef, 0x2c, 0xb2, 0x1c, 0x9f, 0x5d, 0x6f, 0x80, 0x0a, 0x72, 0x44, 0x9b, 0x6c, 
 0x90, 0x0b, 0x5b, 0x33, 0x7d, 0x5a, 0x52, 0xf3, 0x61, 0xa1, 0xf7, 0xb0, 0xd6, 0x3f, 0x7c, 0x6d, 
 0xed, 0x14, 0xe0, 0xa5, 0x3d, 0x22, 0xb3, 0xf8, 0x89, 0xde, 0x71, 0x1a, 0xaf, 0xba, 0xb5, 0x81};*/

        static byte C_Shift(byte k, int t)
        {
            byte res, temp;
            temp = (byte)k;
            temp = (byte)(temp >> 8 - t);
            k = (byte)(k << t);
            res = (byte)(k | temp);
            return res;
        }


        static byte F_function(byte x, byte k)
        {
            byte res;
            res = S_Block[(byte)(x ^ k)];
            return res;
        }
        static byte F2_function(byte x, byte k)
        {
            byte res;
            res = (byte)(S_Block[x] ^ k);
            return res;
        }
        static byte F3_function(byte x, byte k)
        {
            byte res;
            res = (byte)(S_Block[(byte)(x ^ k)] ^ k);
            return res;
        }
        //**
        static byte G_function(byte x, byte k)
        {
            byte res;
            res = F3_function(x, k);
            res = F3_function(res, k);
            return res;
        }
        //**
        static byte R_function(byte x, byte k, int t)
        {
            byte res, k1 = C_Shift(k, t);
            res = F3_function(x, k);
            res = F3_function(res, k1);
            return res;
        }


        static void GetMax(int[,,] matrix)
        {
            int[,] maxValues = new int[256, 256];
            for (int a = 1; a <= 0xff; a++)
                for (int b = 0; b <= 0xff; b++)
                    maxValues[a, b] = Enumerable.Range(0, 256).Select(x => matrix[x, a, b]).Max();

            int[] maxArray = new int[256];
            int[] temp = new int[256];
            for (int i = 0; i <= 0xff; i++)
            {
                for (int j = 0; j <= 0xff; j++)
                {
                    temp[j] = maxValues[i, j];
                }
                maxArray[i] = temp.Max();
            }
            Console.WriteLine("MDP : " + maxArray.Max());
        }

        static byte[,] DDTforF()
        {
            byte key = 0;
            byte[,] counter = new byte[256, 256];
            for (int a = 0; a <= 0xff; a++)
            {
                for (int x = 0; x <= 0xff; x++)
                {
                    counter[a, F_function((byte)((byte)x ^ (byte)a), key) ^ F_function((byte)x, key)]++;
                }
            }
            return counter;
        }


        static double[,] DDTforD2()
        {
            byte key = 0;
            double[,] counter = new double[256, 256];
            byte[,] temp = new byte[256, 256];
            for (int a = 0; a <= 0xff; a++)
            {
                for (int x = 0; x <= 0xff; x++)
                {
                    temp[a, F_function((byte)((byte)x ^ (byte)a), key) ^ F_function((byte)x, key)]++;
                }
            }

            for (int i = 0; i <= 0xff; i++)
            {
                for (int j = 0; j <= 0xff; j++)
                {
                    counter[i, j] = 0;
                    for (int k = 0; k <= 0xff; k++)
                    {
                        counter[i, j] += temp[i, k] * temp[k, j];
                    }
                    counter[i, j] = counter[i, j] / 256;
                    //counter[i, j] = Math.Round(counter[i, j], 3);
                }
            }

            return counter;
        }

        //***
        static double[,] DDTforNewF()
        {
            double[,] counter = new double[256, 256];
            int[,,] temp = new int[256, 256, 256];
            for (int x = 0; x <= 0xff; x++)
                for (int a = 0; a <= 0xff; a++)
                    for (int k = 0; k <= 0xff; k++)
                    {
                        temp[x, a, F2_function((byte)((byte)x ^ (byte)a), (byte)k) ^ F2_function((byte)x, (byte)k)]++;
                    }
            for (int i = 0; i <= 0xff; i++)
            {
                for (int j = 0; j <= 0xff; j++)
                {
                    for (int x = 0; x <= 0xff; x++)
                    {
                        counter[i, j] += temp[x, i, j];
                    }
                    counter[i, j] = counter[i, j] / 256;
                    //counter[i, j] = Math.Round(counter[i, j], 3);
                }

            }
            //GetMax(temp);
            return counter;
        }

        static double[,] DDTforG()
        {
            double[,] counter = new double[256, 256];
            int[,,] temp = new int[256, 256, 256];
            for (int x = 0; x <= 0xff; x++)
                for (int a = 0; a <= 0xff; a++)
                    for (int k = 0; k <= 0xff; k++)
                    {
                        temp[x, a, G_function((byte)((byte)x ^ (byte)a), (byte)k) ^ G_function((byte)x, (byte)k)]++;
                    }
            for (int i = 0; i <= 0xff; i++)
            {
                for (int j = 0; j <= 0xff; j++)
                {
                    for (int x = 0; x <= 0xff; x++)
                    {
                        counter[i, j] += temp[x, i, j];
                    }
                    counter[i, j] = counter[i, j] / 256;
                    //counter[i, j] = Math.Round(counter[i, j], 3);
                }
                //Console.WriteLine(temp[i, 13, 21]);

            }
            GetMax(temp);
            return counter;
        }

        static double[,] DDTforR(int t) // MEDP actualy
        {
            // t -- length of circular shift
            double[,] counter = new double[256, 256];
            int[,,] temp = new int[256, 256, 256];
            for (int x = 0; x <= 0xff; x++)
                for (int a = 0; a <= 0xff; a++)
                    for (int k = 0; k <= 0xff; k++)
                    {
                        temp[x, a, R_function((byte)((byte)x ^ (byte)a), (byte)k, t) ^ R_function((byte)x, (byte)k, t)]++;
                    }
            for (int i = 0; i <= 0xff; i++)
            {
                for (int j = 0; j <= 0xff; j++)
                {
                    for (int x = 0; x <= 0xff; x++)
                    {
                        counter[i, j] += temp[x, i, j];
                    }
                    counter[i, j] = counter[i, j] / (double)256;
                    //counter[i, j] = Math.Round(counter[i, j], 3);
                }
                //Console.WriteLine(temp[i, 13, 21]);
            }
            GetMax(temp);
            return counter;
        }






        static void Calculate_DDTs()
        {
            Console.WriteLine("Processing...");
            var counterForF = DDTforF();                  //filling DDT for F
            //var counterForF = DDTforNewF();                  //filling DDT for F2,3
            //var counterForG = DDTforG();                //filling DDt for G
            var counterForG = DDTforR(2);               //filling DDt for R
            var counterForD2 = DDTforD2();              //filling D2
            double[] temp = new double[256];
            double[] tempDif = new double[256];




            //////////////////////////////////////////////////////////////////////

            //                         analyzing

            //////////////////////////////////////////////////////////////////////


            int ZerosF = 0, ZerosG = 0, ZerosD2 = 0, inc1 = 0, dec1 = 0, con1 = 0, inc2 = 0, dec2 = 0, con2 = 0;
            double[] tmin = new double[255];
            double[] tmax = new double[255];
            double[] tmedp = new double[256];
            double[] medp = new double[255];
            //int MaxCounterF = 0, MaxCounterG = 0, MaxCounterD2 = 0; 
            for (int i = 1; i <= 0xff; i++)
            {
                for (int j = 1; j <= 0xff; j++)
                {
                    //MaxCounterF = counterForF[i, j] == 4 ? MaxCounterF + 1 : MaxCounterF;
                    //MaxCounterG = counterForG[i, j] == 12 ? MaxCounterG + 1 : MaxCounterG;
                    //MaxCounterD2 = Math.Round(counterForD2[i, j], 3) == 1.281 ? MaxCounterD2 + 1 : MaxCounterD2;

                    ZerosF = counterForF[i, j] == 0 ? ZerosF + 1 : ZerosF;                 //zeros for F
                    ZerosG = counterForG[i, j] == 0 ? ZerosG + 1 : ZerosG;                 //zeros for G/R
                    ZerosD2 = counterForD2[i, j] == 0 ? ZerosD2 + 1 : ZerosD2;             //zeros for D2
                    con1 = counterForG[i, j] == counterForF[i, j] ? con1 + 1 : con1;       //constant for G/R
                    con2 = counterForD2[i, j] == counterForG[i, j] ? con2 + 1 : con2;  //*    //constant for D2
                    inc1 = counterForG[i, j] > counterForF[i, j] ? inc1 + 1 : inc1;        //increased for G/R
                    inc2 = counterForD2[i, j] > counterForG[i, j] ? inc2 + 1 : inc2;   //*    //increased for D2
                    dec1 = counterForG[i, j] < counterForF[i, j] ? dec1 + 1 : dec1;        //decreased dor G/R
                    dec2 = counterForD2[i, j] < counterForG[i, j] ? dec2 + 1 : dec2;   //*    //decreased for D2
                    tempDif[j] = counterForF[i, j] - counterForG[i, j];                  //*
                    tempDif[j] = Math.Round(tempDif[j], 3);
                    tmedp[j] = counterForG[i, j]; tmedp[j] = Math.Round(tmedp[j], 3);
                }
                tmax[i - 1] = tempDif.Max();
                tmin[i - 1] = tempDif.Min();
                medp[i - 1] = tmedp.Max();
            }
            //Console.WriteLine("# max F :" + MaxCounterF);
            //Console.WriteLine("# max G :" + MaxCounterG);
            //Console.WriteLine("# max D2 :" + MaxCounterD2);

            //Console.WriteLine("Con: " + con2);
            //Console.WriteLine("Inc: " + inc2);
            //Console.WriteLine("Dec: " + dec2);

            Console.WriteLine("MEDP: " + medp.Max());
            Console.WriteLine("Max diff: " + tmax.Max());
            Console.WriteLine("Min diff: " + tmin.Min());


            Console.WriteLine("Done");








            //string path = @"DDT for AES.txt";
            //string path = @"DDT for Kalina 1.txt";
            //string path = @"DDT for Kalina 2.txt";
            //string path = @"DDT for Kalina 3.txt";
            //string path = @"DDT for Kalina 4.txt";
            //string path = @"DDT for Kuznechik.txt";
            //string path = @"DDT for STB.txt";
            //string path = @"DDT for Aria 1.txt";
            //string path = @"DDT for Aria 2.txt";

            //string path = @"AES shift 2.txt";
            //string path = @"Kalina 1 shift 3.txt";
            //string path = @"Kalina 2 shift 2.txt";
            //string path = @"Kalina 3 shift 3.txt";
            //string path = @"Kalina 4 shift 2.txt";
            //string path = @"Kuznechik shift 3.txt";
            //string path = @"STB shift 2.txt";
            //string path = @"Aria 1 shift 1.txt";
            //string path = @"Aria 2 shift 3.txt";

            string path = @"TEMPTEXT.txt";





            //////////////////////////////////////////////////////////////////////

            //                    writing DDTs to file

            //////////////////////////////////////////////////////////////////////


            Console.WriteLine("Writing to file...");
            using (StreamWriter sw = File.CreateText(path))
            {
                //writing initial DDT
                for (int i = 0; i <= 0xff; i++)
                {
                    for (int j = 0; j <= 0xff; j++)
                    {
                        sw.Write(String.Format("{0,2:D}", counterForF[i, j].ToString())); sw.Write("  ");
                        temp[j] = counterForF[i, j];
                    }
                    sw.Write(" Max :  " + temp.Max() + "\n");
                    Array.Clear(temp, 0, 256);
                }
                sw.WriteLine("Number of zeros :  " + ZerosF);
                sw.WriteLine();
                sw.WriteLine();


                //writing second DDT
                for (int i = 0; i <= 0xff; i++)
                {
                    for (int j = 0; j <= 0xff; j++)
                    {
                        sw.Write(String.Format("{0,10:D}", counterForG[i, j].ToString())); sw.Write("  ");
                        temp[j] = counterForG[i, j];
                        tempDif[j] = counterForG[i, j] - counterForF[i, j];
                    }
                    sw.Write(" Max :  "); sw.Write(String.Format("{0,10:D}", (temp.Max()).ToString()));
                    sw.Write("   MaxDif :  "); sw.Write(String.Format("{0,10:D}", (tempDif.Max()).ToString()));
                    sw.Write("   MinDif :  "); sw.Write(String.Format("{0,10:D}", (tempDif.Min()).ToString())); sw.Write("\n");
                    Array.Clear(temp, 0, 256);
                }
                sw.WriteLine("Number of zeros :  " + ZerosG);
                sw.WriteLine("Number of constant elements  :  " + con1);
                sw.WriteLine("Number of increased elements :  " + inc1);
                sw.WriteLine("Number of decreased elements :  " + dec1);
                sw.WriteLine();
                sw.WriteLine();

                //writing D2
                for (int i = 0; i <= 0xff; i++)
                {
                    for (int j = 0; j <= 0xff; j++)
                    {
                        sw.Write(String.Format("{0,6:D}", (counterForD2[i, j]).ToString())); sw.Write("  ");
                        temp[j] = counterForD2[i, j];
                        tempDif[j] = counterForD2[i, j] - counterForF[i, j];
                    }
                    sw.Write(" Max :  "); sw.Write(String.Format("{0,6:D}", (temp.Max()).ToString()));
                    sw.Write("   MaxDif :  "); sw.Write(String.Format("{0,6:D}", (tempDif.Max()).ToString()));
                    sw.Write("   MinDif :  "); sw.Write(String.Format("{0,6:D}", (tempDif.Min()).ToString())); sw.Write("\n");
                    Array.Clear(temp, 0, 256);
                }
                sw.WriteLine("Number of zeros :  " + ZerosD2);
                sw.WriteLine("Number of constant elements  :  " + con2);
                sw.WriteLine("Number of increased elements :  " + inc2);
                sw.WriteLine("Number of decreased elements :  " + dec2);
                sw.WriteLine();
                sw.WriteLine();
            }

            Console.WriteLine("Done");

        }

        public static int[] NumberToArray(int number)
        {
            string binary = Convert.ToString(number, 2).PadLeft(8, '0');
            return binary.Select(x => Convert.ToInt32(x.ToString())).ToArray<int>();
        }


        static int[,] ScalProd()
        {
            int[,] res = new int[256, 256];
            for (int a = 0; a <= 0xff; a++)
            {
                for (int b = 0; b <= 0xff; b++)
                {
                    var vectorA = NumberToArray(a);
                    var vectorB = NumberToArray(b);
                    var resultVector = new int[8];
                    for (int i = 0; i < 8; i++)
                        resultVector[i] = vectorA[i] * vectorB[i];
                    res[a, b] = resultVector.Sum() % 2;
                }
            }

            return res;
        }

        //**
        static void MELPR1()
        {
            float[,,] LP = new float[256, 256, 256];
            float[,] ELP = new float[256, 256];
            var ScalarProduct = ScalProd();
            float sum;
            for (int k = 0; k <= 0xff; k++)
            {
                for (int a = 0; a <= 0xff; a++)
                {
                    for (int b = 0; b <= 0xff; b++)
                    {
                        sum = 0;
                        for (int x = 0; x <= 0xff; x++)
                        {
                            var result1 = ScalarProduct[a, x];
                            var result2 = ScalarProduct[b, R_function((byte)x, (byte)k, 1)];
                            var exp = result1 ^ result2;
                            sum += (float)Math.Pow(-1, exp);
                        }
                        sum /= 256;
                        sum *= sum;
                        LP[a, b, k] = sum;
                    }
                }
                //Console.WriteLine(k);
            }
            for (int a = 0; a <= 0xff; a++)
            {
                for (int b = 0; b <= 0xff; b++)
                {
                    for (int k = 0; k <= 0xff; k++)
                    {
                        ELP[a, b] += LP[a, b, k];
                    }
                    ELP[a, b] /= 256;
                }
            }
            float[] maxValues = new float[255];
            for (int b = 1; b <= 0xfe; b++)
                maxValues[b] = Enumerable.Range(0, 256).Select(x => ELP[x, b]).Max();

            Console.WriteLine("MELP: " + maxValues.Max());

        }

        static void MELPR2()
        {
            float[,,] LP = new float[256, 256, 256];
            float[,] ELP = new float[256, 256];
            var ScalarProduct = ScalProd();
            float sum;
            for (int k = 0; k <= 0xff; k++)
            {
                for (int a = 0; a <= 0xff; a++)
                {
                    for (int b = 0; b <= 0xff; b++)
                    {
                        sum = 0;
                        for (int x = 0; x <= 0xff; x++)
                        {
                            var result1 = ScalarProduct[a, x];
                            var result2 = ScalarProduct[b, R_function((byte)x, (byte)k, 2)];
                            var exp = result1 ^ result2;
                            sum += (float)Math.Pow(-1, exp);
                        }
                        sum /= 256;
                        sum *= sum;
                        LP[a, b, k] = sum;
                    }
                }
                //Console.WriteLine(k);
            }
            for (int a = 0; a <= 0xff; a++)
            {
                for (int b = 0; b <= 0xff; b++)
                {
                    for (int k = 0; k <= 0xff; k++)
                    {
                        ELP[a, b] += LP[a, b, k];
                    }
                    ELP[a, b] /= 256;
                }
            }
            float[] maxValues = new float[255];
            for (int b = 1; b <= 0xfe; b++)
                maxValues[b] = Enumerable.Range(0, 256).Select(x => ELP[x, b]).Max();

            Console.WriteLine("MELP: " + maxValues.Max());

        }





        static void MELPH()
        {
            float[,,] LP = new float[256, 256, 256];
            float[,] ELP = new float[256, 256];
            var ScalarProduct = ScalProd();
            float sum;
            for (int k = 0; k <= 0xff; k++)
            {
                for (int a = 0; a <= 0xff; a++)
                {
                    for (int b = 0; b <= 0xff; b++)
                    {
                        sum = 0;
                        for (int x = 0; x <= 0xff; x++)
                        {
                            var result1 = ScalarProduct[a, x];
                            var result2 = ScalarProduct[b, F_function((byte)x, (byte)k)];
                            var exp = result1 ^ result2;
                            sum += (float)Math.Pow(-1, exp);
                        }
                        sum /= 256;
                        sum *= sum;
                        LP[a, b, k] = sum;
                    }
                }
            }
            for (int a = 0; a <= 0xff; a++)
            {
                for (int b = 0; b <= 0xff; b++)
                {
                    for (int k = 0; k <= 0xff; k++)
                    {
                        ELP[a, b] += LP[a, b, k];
                    }
                    ELP[a, b] /= 256;
                }
            }
            float[,] newELP = new float[256, 256];
            for (int i = 0; i <= 0xff; i++)
            {
                for (int j = 0; j <= 0xff; j++)
                {
                    newELP[i, j] = 0;
                    for (int k = 0; k <= 0xff; k++)
                    {
                        newELP[i, j] += ELP[i, k] * ELP[k, j];
                    }
                    //newELP[i, j] = newELP[i, j] / 256;
                }
            }
            float[] maxValues = new float[255];
            for (int b = 1; b <= 0xfe; b++)
                maxValues[b] = Enumerable.Range(0, 256).Select(x => newELP[x, b]).Max();

            Console.WriteLine("MELP: " + maxValues.Max());

        }

        static void Main(string[] args)
        {
            Calculate_DDTs();
            

            Console.ReadKey();
        }
    }
}
